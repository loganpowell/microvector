name: Update Changelog

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Release tag name (must be an existing tag, e.g., v0.2.18)'
        required: true
        type: string
      regenerate:
        description: 'Force regenerate even if changelog exists for this version'
        required: false
        type: boolean
        default: false

permissions:
  contents: write # Needed to commit changelog updates
  models: read # Needed to access GitHub Models

jobs:
  update-changelog:
    name: Generate and Update Changelog
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for git diff
          fetch-tags: true # Ensure all tags are fetched
          ref: main # Checkout main branch to get latest CHANGELOG.md

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true

      - name: Install dependencies
        run: uv sync --dev

      - name: Validate tag exists
        id: validate_tag
        run: |
          # Get current tag from either release event or manual input
          if [ -n "${{ github.event.release.tag_name }}" ]; then
            CURRENT_TAG="${{ github.event.release.tag_name }}"
            echo "🎯 Triggered by release event for tag: $CURRENT_TAG"
          else
            CURRENT_TAG="${{ inputs.tag_name }}"
            echo "🎯 Triggered manually for tag: $CURRENT_TAG"
            
            # Validate that the tag exists
            if ! git rev-parse "$CURRENT_TAG" >/dev/null 2>&1; then
              echo "❌ Error: Tag '$CURRENT_TAG' does not exist!"
              echo "Available tags:"
              git tag --sort=-version:refname | head -10
              exit 1
            fi
            
            echo "✅ Tag '$CURRENT_TAG' exists"
          fi
          
          # Export for use in other steps
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT

      - name: Get previous release tag
        id: prev_release
        run: |
          # Source shared release range utilities
          source scripts/get_release_range.sh
          
          # Use validated tag from previous step
          CURRENT_TAG="${{ steps.validate_tag.outputs.current_tag }}"
          
          echo "📦 Processing release: $CURRENT_TAG"
          
          # Get commit range for this release
          get_release_range "$CURRENT_TAG" "false"  # false = use tag as upper bound (not changelog commit)
          
          echo "📊 Commit range:"
          echo "  Lower bound: $LOWER_BOUND"
          echo "  Upper bound: $UPPER_BOUND"
          echo "  Previous tag: $PREV_TAG"
          
          # Export outputs for next steps
          echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "lower_bound=$LOWER_BOUND" >> $GITHUB_OUTPUT
          echo "upper_bound=$UPPER_BOUND" >> $GITHUB_OUTPUT
          
          if [ "$LOWER_BOUND" = "$(git rev-list --max-parents=0 HEAD)" ]; then
            echo "first_release=true" >> $GITHUB_OUTPUT
          else
            echo "first_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate git diff
        id: git_diff
        run: |
          LOWER_BOUND="${{ steps.prev_release.outputs.lower_bound }}"
          UPPER_BOUND="${{ steps.prev_release.outputs.upper_bound }}"
          
          echo "🔍 Debug - Bounds for diff:"
          echo "  Lower: $LOWER_BOUND"
          echo "  Upper: $UPPER_BOUND"

          # Generate summary of changed files
          git diff --stat ${LOWER_BOUND}..${UPPER_BOUND} > diff_summary.txt

          # Get commit messages using shared utility
          source scripts/get_release_range.sh
          get_commits_with_hash "${LOWER_BOUND}" "${UPPER_BOUND}" "true" > commits.txt || echo "- No commits found" > commits.txt
          
          echo "📝 Commits found:"
          cat commits.txt

          # Generate diff for functional code only (exclude config/docs)
          # Filter out: .md, .yml, .yaml, .sh, .json, .toml, .txt, .rst
          # --diff-filter=ACM: Only Added, Copied, Modified (excludes Deleted, Renamed)
          git diff --diff-filter=ACM ${LOWER_BOUND}..${UPPER_BOUND} -- \
            ':!*.md' ':!*.yml' ':!*.yaml' ':!*.json' \
            ':!*.toml' ':!*.txt' ':!*.rst' ':!*.cfg' ':!*.ini' \
            > functional_diff.txt

          echo "✅ Git diff generated"
          echo "📊 Changed files:"
          cat diff_summary.txt

      - name: Download benchmark results
        id: download_benchmarks
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: benchmark-results-python-*
          merge-multiple: true
          path: ./benchmark-data

      - name: Prepare benchmark summary
        id: benchmark_summary
        run: |
          # Use the script to prepare benchmark summary
          if uv run python scripts/prepare_benchmarks.py \
            --input ./benchmark-data \
            --output benchmark_summary.txt; then
            echo "has_benchmarks=true" >> $GITHUB_OUTPUT
          else
            echo "has_benchmarks=false" >> $GITHUB_OUTPUT
          fi

      - name: Install gh-models extension
        run: |
          gh extension install https://github.com/github/gh-models
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate changelog entry with AI
        id: generate_changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use validated tag from previous step
          CURRENT_TAG="${{ steps.validate_tag.outputs.current_tag }}"
          PREV_TAG="${{ steps.prev_release.outputs.prev_tag }}"
          IS_FIRST="${{ steps.prev_release.outputs.first_release }}"

          # Truncate functional diff using the script
          # Note: grok-3 has 4000 token limit for entire request body
          # Reserve ~1500 tokens for commits, files summary, and prompt
          uv run python scripts/truncate_diff.py \
            functional_diff.txt \
            truncated_diff.txt \
            --max-tokens 2500

          # Create a concise context file for the AI
          cat > ai_context.txt << CONTEXT_EOF
          Release: ${CURRENT_TAG} (from ${PREV_TAG})

          Commits:
          $(cat commits.txt)

          Files Changed:
          $(cat diff_summary.txt | grep -E '\.(py|js|ts|jsx|tsx|c|cpp|h|go|rs|java)' | grep -v '/tests/' | head -15)

          Here's a diff of the changes:
          $(cat truncated_diff.txt)
          CONTEXT_EOF

          # Use GitHub Models to generate categorized changelog content (without header)
          if cat ai_context.txt | gh models run xai/grok-3 \
            "Based on commit messages and code changes, create a categorized changelog.

          Format (do NOT include version header, just categories):

          ### [Category]
          - User-facing description

          Categories to use: Added, Changed, Fixed, Performance, Deprecated, Removed, Security.
          Be concise, but don't skimp on the flare to get users excited about new features." \
          > ai_changelog_content.md; then
            echo "✅ AI changelog content generated"
            echo "📝 AI Content Preview:"
            cat ai_changelog_content.md
            
            # Add the version header ourselves
            cat > changelog_entry.md << ENTRY_EOF
          ## [${CURRENT_TAG}] - $(date +%Y-%m-%d)

          $(cat ai_changelog_content.md)
          ENTRY_EOF
          else
            echo "⚠️ AI generation failed, creating basic changelog from commits"
            cat > changelog_entry.md << FALLBACK_EOF
          ## [${CURRENT_TAG}] - $(date +%Y-%m-%d)

          ### Changed

          $(cat commits.txt | sed 's/^- /- /' | sed 's/ ([a-f0-9]\{7\})$//')

          FALLBACK_EOF
          fi
          
          echo "📝 Final changelog entry:"
          cat changelog_entry.md

      - name: Update CHANGELOG.md
        run: |
          # Use validated tag from previous step
          CURRENT_TAG="${{ steps.validate_tag.outputs.current_tag }}"
          
          # Check if we should force regeneration
          FORCE_FLAG=""
          if [ "${{ inputs.regenerate }}" = "true" ]; then
            FORCE_FLAG="--force"
            echo "🔄 Force regeneration enabled"
          fi
          
          # Use the script to update CHANGELOG.md
          uv run python scripts/update_changelog.py \
            --changelog CHANGELOG.md \
            --entry changelog_entry.md \
            --version "$CURRENT_TAG" \
            --repo "https://github.com/${{ github.repository }}" \
            $FORCE_FLAG

          echo "📄 Updated CHANGELOG.md:"
          head -n 50 CHANGELOG.md

      - name: Commit and push changelog
        run: |
          # Use validated tag from previous step
          CURRENT_TAG="${{ steps.validate_tag.outputs.current_tag }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "chore: update CHANGELOG for $CURRENT_TAG" || echo "No changes to commit"
          git push

      - name: Update release notes with changelog
        if: github.event_name == 'release'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use validated tag from previous step
          CURRENT_TAG="${{ steps.validate_tag.outputs.current_tag }}"
          
          # Build release notes with AI-generated changelog and link to full CHANGELOG
          CHANGELOG_CONTENT=$(cat changelog_entry.md)
          
          # Generate GitHub markdown anchor
          # GitHub removes dots, brackets, and other special chars, keeps dashes
          # Example: [v0.2.18] - 2025-10-28 becomes v0218---2025-10-28
          VERSION_NO_DOTS="${CURRENT_TAG//./}"
          VERSION_ANCHOR="${VERSION_NO_DOTS}---$(date +%Y-%m-%d)"
          
          RELEASE_NOTES="$CHANGELOG_CONTENT

          ---

          📝 [View Full Changelog](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md#${VERSION_ANCHOR})"
          
          # Update release notes
          gh release edit "$CURRENT_TAG" --notes "$RELEASE_NOTES"
          
          echo "✅ Updated release notes for $CURRENT_TAG"
